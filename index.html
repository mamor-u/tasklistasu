<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>タスク管理</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        #controls {
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            padding: 10px 16px;
            font-size: 16px;
            cursor: pointer;
        }
        button:disabled {
            opacity: 0.5;
            cursor: default;
        }

        #matrix-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1/1;
            border: 2px solid #333;
            background: #f9f9f9;
        }

        canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .task {
            position: absolute;
            width: 30%;
            min-width: 90px;
            max-width: 130px;
            padding: 6px 10px;
            color: white;
            border-radius: 6px;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 10;
            font-size: 13px;
            text-align: center;
        }
        .task.selected {
            outline: 3px solid red;
        }

        #taskList {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 600px;
        }

        .task-list-item {
            padding: 6px 10px;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            font-size: 13px;
            cursor: grab;
            user-select: none;
        }
        .task-list-item.selected {
            outline: 2px solid red;
        }

        #totalTime {
            font-weight: bold;
            margin-top: 10px;
        }

        /* ▼ 追加：完了タスク一覧エリア用 */
        #completedTaskList {
            display: none;
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
            max-width: 600px;
        }
        .completed-item {
            background-color: #666;
            color: #fff;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="addTaskBtn">タスク追加</button>
        <button id="editTaskBtn" disabled>編集</button>
        <button id="deselectTaskBtn" disabled>選択解除</button>
        <button id="deleteTaskBtn" disabled>削除</button>

        <!-- ▼ 新規追加ボタン -->
        <button id="completeTaskBtn" disabled>タスク完了</button>
        <button id="toggleCompletedBtn">完了タスク一覧</button>

        <button id="recommendBtn">おすすめ優先順位</button>
    </div>

    <div id="matrix-container"><canvas id="axisCanvas" width="600" height="600"></canvas></div>
    <div id="totalTime">全タスクの合計時間: 0時間0分</div>
    <div id="selectedTime">選択タスクの合計時間: 0時間0分</div>

    <div id="taskList"></div>
    <div id="completedTaskList"></div>

    <!-- 既存モーダル -->
    <div id="taskModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:1000;">
        <div style="background:white; padding:20px; border-radius:8px; width:300px;">
            <h3 id="modalTitle">タスク追加</h3>
            <label>タスク名:<br><input type="text" id="modalTaskName" style="width:100%;"></label><br><br>
            <label>作業時間:<br><div style="display:flex; gap:6px; align-items:center;"><input type="number" id="modalTaskHours" min="0" value="0" style="width:60px;"> 時間<input type="number" id="modalTaskMinutes" min="0" max="59" value="0" style="width:60px;"> 分</div></label><br><br>
            <label>期限:<br><input type="date" id="modalTaskDeadline" style="width:100%;"></label><br><br>
            <label>色を選択:<br><input type="color" id="modalTaskColor" value="#4a90e2"></label><br><br>
            <div style="text-align:right;">
                <button id="modalCancelBtn">キャンセル</button>
                <button id="modalAddBtn">追加</button>
            </div>
        </div>
    </div>

    <script>
        /* ここから元のコード開始 */
        const MATRIX_SIZE = Math.min(window.innerWidth, window.innerHeight, 600);
        const COORD_MIN = 0;
        const COORD_MAX = 100;
        const UNIT_PX = MATRIX_SIZE / COORD_MAX;

        const matrix = document.getElementById('matrix-container');
        const axisCanvas = document.getElementById('axisCanvas');
        const ctx = axisCanvas.getContext('2d');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const editTaskBtn = document.getElementById('editTaskBtn');
        const deleteTaskBtn = document.getElementById('deleteTaskBtn');
        const deselectTaskBtn = document.getElementById('deselectTaskBtn');
        const recommendBtn = document.getElementById('recommendBtn');
        const completeTaskBtn = document.getElementById('completeTaskBtn'); // 追加
        const toggleCompletedBtn = document.getElementById('toggleCompletedBtn'); // 追加
        const taskList = document.getElementById('taskList');
        const completedTaskList = document.getElementById('completedTaskList'); // 追加

        const modal = document.getElementById('taskModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalTaskName = document.getElementById('modalTaskName');
        const modalTaskHours = document.getElementById('modalTaskHours');
        const modalTaskMinutes = document.getElementById('modalTaskMinutes');
        const modalTaskDeadline = document.getElementById('modalTaskDeadline');
        const modalTaskColor = document.getElementById('modalTaskColor');
        const modalAddBtn = document.getElementById('modalAddBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');

        axisCanvas.width = MATRIX_SIZE;
        axisCanvas.height = MATRIX_SIZE;

        let selectedTasks = new Set();
        let editTarget = null;

        const STORAGE_KEY = 'eisenhower_tasks';
        const ORDER_KEY = 'eisenhower_tasks_order';
        const SHIFT_KEY = 'eisenhower_last_shift_date';
        const COMPLETED_KEY = 'eisenhower_completed_tasks'; // 追加

        /* ▼ 時間フォーマット関数追加 */
        function formatTime(minutes) {
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            return `${h}時間${m}分`;
        }

        /* ▼ ラベル表示変更 */
        function labelText(task) {
            let t = `${task.dataset.name}（${formatTime(task.dataset.time)}）`;
            if (task.dataset.deadline) t += `\n期限:${task.dataset.deadline}`;
            return t;
        }

        /* ▼ 時間合計系の表示修正 */
        function updateSelectedTime() {
            let total = 0;
            selectedTasks.forEach(task => { total += parseInt(task.dataset.time); });
            document.getElementById('selectedTime').textContent = `選択タスクの合計時間: ${formatTime(total)}`;
        }

        function updateTotalTime() {
            let total = 0;
            document.querySelectorAll('.task').forEach(task => { total += parseInt(task.dataset.time); });
            document.getElementById('totalTime').textContent = `全タスクの合計時間: ${formatTime(total)}`;
        }

        /* ▼ 完了タスク保存関連 */
        function saveCompletedTask(task) {
            const list = JSON.parse(localStorage.getItem(COMPLETED_KEY) || '[]');
            list.push({
                id: task.dataset.id,
                name: task.dataset.name,
                time: parseInt(task.dataset.time),
                color: rgbToHex(task.style.backgroundColor),
                deadline: task.dataset.deadline,
                completedAt: new Date().toLocaleString()
            });
            localStorage.setItem(COMPLETED_KEY, JSON.stringify(list));
        }

        function renderCompletedTasks() {
            completedTaskList.innerHTML = '';
            const list = JSON.parse(localStorage.getItem(COMPLETED_KEY) || '[]');
            if (list.length === 0) {
                completedTaskList.innerHTML = '<p>完了タスクはありません。</p>';
                return;
            }
            list.forEach(t => {
                const div = document.createElement('div');
                div.className = 'completed-item';
                div.textContent = `${t.name}（${formatTime(t.time)}） 期限:${t.deadline || 'なし'} 完了日時:${t.completedAt}`;
                div.style.backgroundColor = t.color;
                completedTaskList.appendChild(div);
            });
        }

        /* ▼ タスク完了ボタン機能 */
        completeTaskBtn.addEventListener('click', () => {
            if (selectedTasks.size === 0) return;
            selectedTasks.forEach(task => {
                saveCompletedTask(task);
                matrix.removeChild(task);
            });
            clearSelection();
            updateTaskListOrder();
            updateTotalTime();
            saveTasksToLocalStorage();
        });

        /* ▼ 完了一覧の表示切替 */
        let showingCompleted = false;
        toggleCompletedBtn.addEventListener('click', () => {
            showingCompleted = !showingCompleted;
            if (showingCompleted) {
                taskList.style.display = 'none';
                completedTaskList.style.display = 'block';
                toggleCompletedBtn.textContent = 'タスク一覧に戻る';
                renderCompletedTasks();
            } else {
                taskList.style.display = 'flex';
                completedTaskList.style.display = 'none';
                toggleCompletedBtn.textContent = '完了タスク一覧';
            }
        });

        /* ▼ 選択時のUI制御に完了ボタンも追加 */
        function selectTask(task) {
            const id = task.dataset.id;
            if (!selectedTasks.has(task)) {
                task.classList.add('selected');
                selectedTasks.add(task);
            } else {
                task.classList.remove('selected');
                selectedTasks.delete(task);
            }
            document.querySelectorAll('.task-list-item').forEach(item => {
                if (item.dataset.id === id) {
                    if (selectedTasks.has(task)) item.classList.add('selected');
                    else item.classList.remove('selected');
                }
            });
            deleteTaskBtn.disabled = selectedTasks.size === 0;
            deselectTaskBtn.disabled = selectedTasks.size === 0;
            editTaskBtn.disabled = selectedTasks.size !== 1;
            completeTaskBtn.disabled = selectedTasks.size === 0; // ←追加
            updateSelectedTime();
        }

        /* ▼ clearSelection修正 */
        function clearSelection() {
            selectedTasks.forEach(task => task.classList.remove('selected'));
            selectedTasks.clear();
            document.querySelectorAll('.task-list-item').forEach(item => item.classList.remove('selected'));
            deleteTaskBtn.disabled = true;
            deselectTaskBtn.disabled = true;
            editTaskBtn.disabled = true;
            completeTaskBtn.disabled = true; // ←追加
            updateSelectedTime();
        }

        // --- 表示更新 ---
        function updateTaskCoord(task) {
            const leftPx = parseFloat(task.style.left);
            const topPx = parseFloat(task.style.top);
            const rect = task.getBoundingClientRect();
            const halfW = rect.width / 2;
            const halfH = rect.height / 2;
            const centerX = leftPx + halfW;
            const centerY = topPx + halfH;
            const coord = pxToCoord(centerX, centerY);
            task.dataset.x = coord.x;
            task.dataset.y = coord.y;
            task.textContent = labelText(task);
            updateTaskListOrder();
        }

        function updateTaskListOrder(orderIds = null) {
            let tasks = Array.from(document.querySelectorAll('.task'));
            if (!orderIds) {
                // おすすめ（初期）優先順位: y降順 -> x降順
                tasks.sort((a, b) => {
                    const ay = parseInt(a.dataset.y), ax = parseInt(a.dataset.x);
                    const by = parseInt(b.dataset.y), bx = parseInt(b.dataset.x);
                    if (by !== ay) return by - ay;
                    return bx - ax;
                });
            } else {
                // 指定順並び
                const idx = new Map(orderIds.map((id, i) => [id, i]));
                tasks.sort((a, b) => (idx.get(a.dataset.id) ?? 9999) - (idx.get(b.dataset.id) ?? 9999));
            }

            taskList.innerHTML = '';
            tasks.forEach(task => {
                const listItem = document.createElement('div');
                listItem.className = 'task-list-item';
                listItem.dataset.id = task.dataset.id;
                listItem.textContent = `${task.dataset.name}（${formatTime(parseInt(task.dataset.time))}）` + (task.dataset.deadline ? ` 期限:${task.dataset.deadline}` : '');
                listItem.style.backgroundColor = task.style.backgroundColor;
                if (selectedTasks.has(task)) listItem.classList.add('selected');

                // 並べ替え: Drag & Drop
                listItem.draggable = true;
                listItem.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', task.dataset.id);
                });
                listItem.addEventListener('dragover', e => e.preventDefault());
                listItem.addEventListener('drop', e => {
                    e.preventDefault();
                    const draggedId = e.dataTransfer.getData('text/plain');
                    const items = Array.from(taskList.children).map(ch => ch.dataset.id);
                    const from = items.indexOf(draggedId);
                    const to = items.indexOf(listItem.dataset.id);
                    if (from === -1 || to === -1) return;
                    items.splice(to, 0, items.splice(from, 1)[0]);
                    updateTaskListOrder(items);
                    saveOrderToLocalStorage(items);
                });

                listItem.addEventListener('click', () => selectTask(task));

                taskList.appendChild(listItem);
            });
        }



	  function drawAxes() {
    		ctx.clearRect(0, 0, axisCanvas.width, axisCanvas.height);
    		ctx.strokeStyle = "#333";
    		ctx.lineWidth = 2;
    		ctx.beginPath();
    		ctx.moveTo(0, MATRIX_SIZE / 2);
    		ctx.lineTo(MATRIX_SIZE, MATRIX_SIZE / 2);
    		ctx.moveTo(MATRIX_SIZE / 2, 0);
    		ctx.lineTo(MATRIX_SIZE / 2, MATRIX_SIZE);
    		ctx.stroke();
	  }

        // --- ドラッグで移動（キャンバス上） ---
        function makeDraggable(task) {
            let offsetX, offsetY;
            function onPointerDown(e) {
                if (e.button !== 0) return;
                e.preventDefault();
                const rect = task.getBoundingClientRect();
                offsetX = e.clientX - (rect.left + rect.width / 2);
                offsetY = e.clientY - (rect.top + rect.height / 2);
                document.addEventListener('pointermove', onPointerMove);
                document.addEventListener('pointerup', onPointerUp);
                task.style.cursor = 'grabbing';
            }
            function onPointerMove(e) {
                const matrixRect = matrix.getBoundingClientRect();
                let x = e.clientX - matrixRect.left - offsetX;
                let y = e.clientY - matrixRect.top - offsetY;
                const halfW = task.offsetWidth / 2;
                const halfH = task.offsetHeight / 2;
                let coord = pxToCoord(x, y);
                coord.x = Math.round(coord.x / 5) * 5;
                coord.y = Math.round(coord.y / 5) * 5;
                const pos = coordToPx(coord.x, coord.y);
                task.style.left = `${pos.left - halfW}px`;
                task.style.top = `${pos.top - halfH}px`;
                updateTaskCoord(task);
                saveTasksToLocalStorage();
            }
            function onPointerUp() {
                document.removeEventListener('pointermove', onPointerMove);
                document.removeEventListener('pointerup', onPointerUp);
                task.style.cursor = 'grab';
            }
            task.addEventListener('pointerdown', onPointerDown);
        }

        // --- タスク作成 ---
        function createTask(name, time, color, deadline, x = 50, y = 50, id = null) {
            const task = document.createElement('div');
            task.className = 'task';
            task.dataset.id = id || generateId();
            task.dataset.name = name;
            task.dataset.time = time;
            task.dataset.deadline = deadline || '';
            task.style.backgroundColor = color;

            task.addEventListener('click', e => { e.stopPropagation(); selectTask(task); });
            makeDraggable(task);
            matrix.appendChild(task);
            const px = coordToPx(x, y);
            task.style.left = `${px.left - 65}px`;
            task.style.top = `${px.top - 20}px`;
            updateTaskCoord(task);
            updateTaskListOrder(getOrderFromLocalStorage());
            updateTotalTime();
            saveTasksToLocalStorage();
        }

        // --- モーダル操作 ---
        addTaskBtn.addEventListener('click', () => {
            editTarget = null;
            modalTitle.textContent = 'タスク追加';
            modalAddBtn.textContent = '追加';
            modal.style.display = 'flex';
            modalTaskName.value = '';
            modalTaskHours.value = 0;
		modalTaskMinutes.value = 1;
            modalTaskDeadline.value = '';
            modalTaskColor.value = '#4a90e2';
        });

        editTaskBtn.addEventListener('click', () => {
            if (selectedTasks.size !== 1) return;
            editTarget = [...selectedTasks][0];
            modalTitle.textContent = 'タスク編集';
            modalAddBtn.textContent = '更新';
            modalTaskName.value = editTarget.dataset.name;
		const total = parseInt(editTarget.dataset.time, 10) || 0;
    		modalTaskHours.value = Math.floor(total / 60);
    		modalTaskMinutes.value = total % 60;
            modalTaskDeadline.value = editTarget.dataset.deadline;
            modalTaskColor.value = rgbToHex(editTarget.style.backgroundColor) || '#4a90e2';
            modal.style.display = 'flex';
        });

        modalAddBtn.addEventListener('click', () => {
    		const name = modalTaskName.value.trim();
    		const hours = parseInt(modalTaskHours.value, 10) || 0;
    		const minutes = parseInt(modalTaskMinutes.value, 10) || 0;
    		const time = hours * 60 + minutes; // 合計分

    		const deadline = modalTaskDeadline.value;
    		const color = modalTaskColor.value;

    		// バリデーション（以前と同様に0分以下は受け付けない）
    		if (!name || isNaN(time) || time <= 0) return;

    		if (editTarget) {
        		editTarget.dataset.name = name;
        		editTarget.dataset.time = String(time); // dataset は文字列として扱われるので念のため String()
        		editTarget.dataset.deadline = deadline || '';
        		editTarget.style.backgroundColor = color;
        		editTarget.textContent = labelText(editTarget);
        		updateTaskListOrder(getOrderFromLocalStorage());
        		updateTotalTime();
        		saveTasksToLocalStorage();
   		} else {
        		createTask(name, time, color, deadline);
    		}
    		modal.style.display = 'none';
	});

        modalCancelBtn.addEventListener('click', () => { modal.style.display = 'none'; });

        // --- 削除/選択解除 ---
        deleteTaskBtn.addEventListener('click', () => {
            const idsToRemove = [];
            selectedTasks.forEach(task => {
                idsToRemove.push(task.dataset.id);
                matrix.removeChild(task);
            });
            clearSelection();
            updateTaskListOrder(getOrderFromLocalStorage()?.filter(id => !idsToRemove.includes(id)) || null);
            updateTotalTime();
            const order = getOrderFromLocalStorage();
            if (order) saveOrderToLocalStorage(order.filter(id => !idsToRemove.includes(id)));
            saveTasksToLocalStorage();
        });

        deselectTaskBtn.addEventListener('click', clearSelection);
        matrix.addEventListener('click', clearSelection);

        // --- おすすめ優先順位 ---
        recommendBtn.addEventListener('click', () => {
            localStorage.removeItem(ORDER_KEY);
            updateTaskListOrder();
        });

        // --- LocalStorage ---
        function saveTasksToLocalStorage() {
            const allTasks = Array.from(document.querySelectorAll('.task')).map(task => ({
                id: task.dataset.id,
                name: task.dataset.name,
                time: parseInt(task.dataset.time),
                color: task.style.backgroundColor,
                x: parseInt(task.dataset.x),
                y: parseInt(task.dataset.y),
                deadline: task.dataset.deadline || ''
            }));
            localStorage.setItem(STORAGE_KEY, JSON.stringify(allTasks));
        }

        function getOrderFromLocalStorage() {
            const raw = localStorage.getItem(ORDER_KEY);
            if (!raw) return null;
            try { return JSON.parse(raw); } catch { return null; }
        }

        function saveOrderToLocalStorage(orderIds) {
            localStorage.setItem(ORDER_KEY, JSON.stringify(orderIds));
        }

        function loadTasksFromLocalStorage() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;
            try {
                const arr = JSON.parse(saved);
                if (!Array.isArray(arr)) return;
                arr.forEach(t => {
                    const id = t.id || generateId();
                    createTask(t.name, parseInt(t.time), t.color, t.deadline, parseInt(t.x), parseInt(t.y), id);
                });
                const order = getOrderFromLocalStorage();
                if (order) updateTaskListOrder(order);
                updateTotalTime();
            } catch (e) {
                console.error('データの読み込みに失敗しました', e);
            }
        }

        // --- 日付変化で y を +2 シフト ---
        function applyDailyShiftIfNeeded() {
            const today = todayStr();
            const last = localStorage.getItem(SHIFT_KEY);
            if (!last) {
                localStorage.setItem(SHIFT_KEY, today);
                return;
            }
            const diff = daysBetween(last, today);
            if (diff <= 0) return;
            const inc = 2 * diff;
            document.querySelectorAll('.task').forEach(task => {
                const x = parseInt(task.dataset.x);
                let y = parseInt(task.dataset.y);
                y = Math.min(COORD_MAX, y + inc);
                task.dataset.y = y;
                const px = coordToPx(x, y);
                const rect = task.getBoundingClientRect();
                const halfW = rect.width / 2;
                const halfH = rect.height / 2;
                task.style.left = `${px.left - halfW}px`;
                task.style.top = `${px.top - halfH}px`;
                task.textContent = labelText(task);
            });
            updateTaskListOrder(getOrderFromLocalStorage());
            saveTasksToLocalStorage();
            localStorage.setItem(SHIFT_KEY, today);
        }

        let currentDateString = todayStr();
        setInterval(() => {
            const nowStr = todayStr();
            if (nowStr !== currentDateString) {
                currentDateString = nowStr;
                applyDailyShiftIfNeeded();
            }
        }, 60 * 1000);

        // --- rgb -> hex 変換（正規表現なし） ---
        function rgbToHex(rgb) {
            if (!rgb) return null;
            if (rgb[0] === '#') return rgb;
            const nums = [];
            let buf = '';
            for (let i = 0; i < rgb.length; i++) {
                const c = rgb[i];
                if (c >= '0' && c <= '9') buf += c;
                else {
                    if (buf.length) { nums.push(parseInt(buf, 10)); buf = ''; }
                }
            }
            if (buf.length) { nums.push(parseInt(buf, 10)); }
            if (nums.length < 3) return null;
            const [r, g, b] = nums;
            const toHex = n => n.toString(16).padStart(2, '0');
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }


        /* --- 最後に初期化 --- */
        document.addEventListener('DOMContentLoaded', () => {
            drawAxes();
            modal.style.display = 'none';
            loadTasksFromLocalStorage();
            applyDailyShiftIfNeeded();
            renderCompletedTasks(); // ←追加
        });
    </script>
</body>
</html>
