<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>タスク管理</title>
    <style>
/* === レイアウト最適化（PC横並び・スマホ縦並び） === */

/* 全体固定表示 */
html, body {
  height: 100%;
  margin: 0;
  overflow: hidden; /* ページ全体スクロール禁止 */
}

/* メイン全体構造をFlex化 */
body {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  height: 100vh;
  box-sizing: border-box;
}

/* 操作ボタンエリア */
#controls-top, #controls-bottom {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin-bottom: 10px;
}

/* === メインコンテンツ全体 === */
#main-container {
  display: flex;
  flex: 1;
  width: 100%;
  max-width: 1100px;
  justify-content: center;
  align-items: stretch;
  overflow: hidden;
}

/* === 左：キャンバス === */
#matrix-container {
  flex: 1;
  max-width: 600px;
  aspect-ratio: 1/1;
  border: 2px solid #333;
  background: #f9f9f9;
  margin: 0 10px;
}

/* === 右：リスト部分 === */
#list-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  max-width: 450px;
  overflow: hidden;
}

/* リストタイトルや時間表示 */
#totalTime, #selectedTime {
  font-weight: bold;
  margin: 5px 0;
}

/* タスク一覧と完了タスク一覧をスクロール可能に */
#taskList, #completedTaskList {
  flex: 1;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  padding-right: 6px;
}

/* スクロールバー控えめ */
#taskList::-webkit-scrollbar, #completedTaskList::-webkit-scrollbar {
  width: 6px;
}
#taskList::-webkit-scrollbar-thumb, #completedTaskList::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.25);
  border-radius: 3px;
}

/* === スマホ対応（縦並び） === */
@media (max-width: 768px) {
  #main-container {
    flex-direction: column;
    align-items: center;
    height: calc(100vh - 120px); /* ボタン分の高さを除外 */
  }

  #matrix-container {
    width: 95%;
    height: 50%;
    max-width: none;
    aspect-ratio: auto;
  }

  #list-container {
    width: 95%;
    height: 50%;
    max-width: none;
    overflow: hidden;
  }

  #taskList, #completedTaskList {
    height: 100%;
    overflow-y: auto;
  }

  button {
    font-size: 14px;
    padding: 8px 12px;
  }
}
    </style>
</head>
<body>
    <div id="controls-top">
        <button id="addTaskBtn">タスク追加</button>
        <button id="editTaskBtn" disabled>編集</button>
        <button id="deselectTaskBtn" disabled>選択解除</button>
        <button id="deleteTaskBtn" disabled>削除</button>
    </div>
    <div id="main-container">
        <div id="matrix-container">
            <canvas id="axisCanvas" width="600" height="600"></canvas>
        </div>
        <div id="list-container">
            <div id="totalTime">全タスクの合計時間: 0時間0分</div>
            <div id="selectedTime">選択タスクの合計時間: 0時間0分</div>
            <div id="taskList"></div>
            <div id="completedTaskList"></div>
        </div>
    </div>
    <div id="controls-bottom">
        <button id="completeTaskBtn" disabled>タスク完了</button>
        <button id="toggleCompletedBtn">完了タスク一覧</button>
        <button id="recommendBtn">おすすめ優先順位</button>
    </div>


    <!-- タスク追加モーダル -->
    <div id="taskModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:1000;">
        <div style="background:white; padding:20px; border-radius:8px; width:300px;">
            <h3 id="modalTitle">タスク追加</h3>
            <label>タスク名:<br><input type="text" id="modalTaskName" style="width:100%;"></label><br><br>
		<label>作業時間:<br>
    			<input type="number" id="modalTaskHours" min="0" value="0" style="width:45px;"> 時間
    			<input type="number" id="modalTaskMinutes" min="0" max="59" value="0" style="width:45px;"> 分
		</label>
            <label>期限:<br><input type="date" id="modalTaskDeadline" style="width:100%;"></label><br><br>
            <label>色を選択:<br><input type="color" id="modalTaskColor" value="#4a90e2"></label><br><br>
            <div style="text-align:right;">
                <button id="modalCancelBtn">キャンセル</button>
                <button id="modalAddBtn">追加</button>
            </div>
        </div>
    </div>

    <script>
        const MATRIX_SIZE = Math.min(window.innerWidth, window.innerHeight, 600);
        const COORD_MIN = 0;
        const COORD_MAX = 100;
        const UNIT_PX = MATRIX_SIZE / COORD_MAX;

	  function coordToPx(x, y) {
      	return { left: x * UNIT_PX, top: MATRIX_SIZE - y * UNIT_PX };
  	  }
  	  function pxToCoord(pxX, pxY) {
      	const x = Math.round(pxX / UNIT_PX);
      	const y = Math.round((MATRIX_SIZE - pxY) / UNIT_PX);
      	return { x: Math.max(COORD_MIN, Math.min(COORD_MAX, x)), y: Math.max(COORD_MIN, Math.min(COORD_MAX, y)) };
  	  }
  	  function generateId() {
      	return 't_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
  	  }
  	  function todayStr() {
      	const d = new Date();
      	const y = d.getFullYear();
      	const m = String(d.getMonth() + 1).padStart(2, '0');
      	const day = String(d.getDate()).padStart(2, '0');
      	return `${y}-${m}-${day}`;
  	  }
  	  function daysBetween(d1Str, d2Str) {
      	const d1 = new Date(d1Str + 'T00:00:00');
      	const d2 = new Date(d2Str + 'T00:00:00');
      	const ms = d2 - d1;
      	return Math.floor(ms / (1000 * 60 * 60 * 24));
  	  }

        const matrix = document.getElementById('matrix-container');
        const axisCanvas = document.getElementById('axisCanvas');
        const ctx = axisCanvas.getContext('2d');
        axisCanvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        matrix.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        const addTaskBtn = document.getElementById('addTaskBtn');
        const editTaskBtn = document.getElementById('editTaskBtn');
        const deleteTaskBtn = document.getElementById('deleteTaskBtn');
        const deselectTaskBtn = document.getElementById('deselectTaskBtn');
        const recommendBtn = document.getElementById('recommendBtn');
        const completeTaskBtn = document.getElementById('completeTaskBtn'); // 追加
        const toggleCompletedBtn = document.getElementById('toggleCompletedBtn'); // 追加
        const taskList = document.getElementById('taskList');
        const completedTaskList = document.getElementById('completedTaskList'); // 追加

        const modal = document.getElementById('taskModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalTaskName = document.getElementById('modalTaskName');
        const modalTaskHours = document.getElementById('modalTaskHours');
        const modalTaskMinutes = document.getElementById('modalTaskMinutes');
        const modalTaskDeadline = document.getElementById('modalTaskDeadline');
        const modalTaskColor = document.getElementById('modalTaskColor');
        const modalAddBtn = document.getElementById('modalAddBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');

        axisCanvas.width = MATRIX_SIZE;
        axisCanvas.height = MATRIX_SIZE;

        let selectedTasks = new Set();
        let editTarget = null;

        const STORAGE_KEY = 'eisenhower_tasks';
        const ORDER_KEY = 'eisenhower_tasks_order';
        const SHIFT_KEY = 'eisenhower_last_shift_date';
        const COMPLETED_KEY = 'eisenhower_completed_tasks'; // 追加

        /* ▼ 時間フォーマット関数追加 */
        function formatTime(minutes) {
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            return `${h}時間${m}分`;
        }

        /* ▼ ラベル表示変更 */
	  function labelText(task) {
    		const minutes = parseInt(task.dataset.time, 10) || 0;
    		let t = `${task.dataset.name}（${formatTime(minutes)}）`;
    		if (task.dataset.deadline) t += `\n期限:${task.dataset.deadline}`;
    		return t;
	  }
        /* ▼ 時間合計系の表示修正 */
        function updateSelectedTime() {
            let total = 0;
            selectedTasks.forEach(task => { total += parseInt(task.dataset.time); });
            document.getElementById('selectedTime').textContent = `選択タスクの合計時間: ${formatTime(total)}`;
        }

        function updateTotalTime() {
            let total = 0;
            document.querySelectorAll('.task').forEach(task => { total += parseInt(task.dataset.time); });
            document.getElementById('totalTime').textContent = `全タスクの合計時間: ${formatTime(total)}`;
        }

        /* ▼ 完了タスク保存関連 */
        function saveCompletedTask(task) {
            const list = JSON.parse(localStorage.getItem(COMPLETED_KEY) || '[]');
            list.push({
                id: task.dataset.id,
                name: task.dataset.name,
                time: parseInt(task.dataset.time),
                color: rgbToHex(task.style.backgroundColor),
                deadline: task.dataset.deadline,
                completedAt: new Date().toLocaleString()
            });
            localStorage.setItem(COMPLETED_KEY, JSON.stringify(list));
        }

        function renderCompletedTasks() {
            completedTaskList.innerHTML = '';
            const list = JSON.parse(localStorage.getItem(COMPLETED_KEY) || '[]');
            if (list.length === 0) {
                completedTaskList.innerHTML = '<p>完了タスクはありません。</p>';
                return;
            }
            list.forEach(t => {
                const div = document.createElement('div');
                div.className = 'completed-item';
                div.textContent = `${t.name}（${formatTime(t.time)}） 期限:${t.deadline || 'なし'} 完了日時:${t.completedAt}`;
                div.style.backgroundColor = t.color;
                completedTaskList.appendChild(div);
            });
        }

        /* ▼ タスク完了ボタン機能 */
        completeTaskBtn.addEventListener('click', () => {
            if (selectedTasks.size === 0) return;
            selectedTasks.forEach(task => {
                saveCompletedTask(task);
                matrix.removeChild(task);
            });
            clearSelection();
            updateTaskListOrder();
            updateTotalTime();
            saveTasksToLocalStorage();
        });

        /* ▼ 完了一覧の表示切替 */
        let showingCompleted = false;
        toggleCompletedBtn.addEventListener('click', () => {
            showingCompleted = !showingCompleted;
            if (showingCompleted) {
                taskList.style.display = 'none';
                completedTaskList.style.display = 'block';
                toggleCompletedBtn.textContent = 'タスク一覧に戻る';
                renderCompletedTasks();
            } else {
                taskList.style.display = 'flex';
                completedTaskList.style.display = 'none';
                toggleCompletedBtn.textContent = '完了タスク一覧';
            }
        });

        /* ▼ 選択時のUI制御 */
        function selectTask(task) {
            const id = task.dataset.id;
            if (!selectedTasks.has(task)) {
                task.classList.add('selected');
                selectedTasks.add(task);
            } else {
                task.classList.remove('selected');
                selectedTasks.delete(task);
            }
            document.querySelectorAll('.task-list-item').forEach(item => {
                if (item.dataset.id === id) {
                    if (selectedTasks.has(task)) item.classList.add('selected');
                    else item.classList.remove('selected');
                }
            });
            deleteTaskBtn.disabled = selectedTasks.size === 0;
            deselectTaskBtn.disabled = selectedTasks.size === 0;
            editTaskBtn.disabled = selectedTasks.size !== 1;
            completeTaskBtn.disabled = selectedTasks.size === 0;
            updateSelectedTime();
        }

        /* ▼ clearSelection */
        function clearSelection() {
            selectedTasks.forEach(task => task.classList.remove('selected'));
            selectedTasks.clear();
            document.querySelectorAll('.task-list-item').forEach(item => item.classList.remove('selected'));
            deleteTaskBtn.disabled = true;
            deselectTaskBtn.disabled = true;
            editTaskBtn.disabled = true;
            completeTaskBtn.disabled = true;
            updateSelectedTime();
        }

        // --- 表示更新 ---
        function updateTaskCoord(task) {
            const leftPx = parseFloat(task.style.left);
            const topPx = parseFloat(task.style.top);
            const rect = task.getBoundingClientRect();
            const halfW = rect.width / 2;
            const halfH = rect.height / 2;
            const centerX = leftPx + halfW;
            const centerY = topPx + halfH;
            const coord = pxToCoord(centerX, centerY);
            task.dataset.x = coord.x;
            task.dataset.y = coord.y;
            task.textContent = labelText(task);
            updateTaskListOrder();
        }

        function updateTaskListOrder(orderIds = null) {
            let tasks = Array.from(document.querySelectorAll('.task'));
            if (!orderIds) {
                // おすすめ（初期）優先順位: y降順 -> x降順
                tasks.sort((a, b) => {
                    const ay = parseInt(a.dataset.y), ax = parseInt(a.dataset.x);
                    const by = parseInt(b.dataset.y), bx = parseInt(b.dataset.x);
                    if (by !== ay) return by - ay;
                    return bx - ax;
                });
            } else {
                // 指定順並び
                const idx = new Map(orderIds.map((id, i) => [id, i]));
                tasks.sort((a, b) => (idx.get(a.dataset.id) ?? 9999) - (idx.get(b.dataset.id) ?? 9999));
            }

            taskList.innerHTML = '';
            tasks.forEach(task => {
                const listItem = document.createElement('div');
                listItem.className = 'task-list-item';
                listItem.dataset.id = task.dataset.id;
                listItem.textContent = `${task.dataset.name}（${formatTime(parseInt(task.dataset.time))}）` + (task.dataset.deadline ? ` 期限:${task.dataset.deadline}` : '');
                listItem.style.backgroundColor = task.style.backgroundColor;
                if (selectedTasks.has(task)) listItem.classList.add('selected');

                // 並べ替え: Drag & Drop
                listItem.draggable = true;
                listItem.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', task.dataset.id);
                });
                listItem.addEventListener('dragover', e => e.preventDefault());
                listItem.addEventListener('drop', e => {
                    e.preventDefault();
                    const draggedId = e.dataTransfer.getData('text/plain');
                    const items = Array.from(taskList.children).map(ch => ch.dataset.id);
                    const from = items.indexOf(draggedId);
                    const to = items.indexOf(listItem.dataset.id);
                    if (from === -1 || to === -1) return;
                    items.splice(to, 0, items.splice(from, 1)[0]);
                    updateTaskListOrder(items);
                    saveOrderToLocalStorage(items);
                });

                listItem.addEventListener('click', () => selectTask(task));

                taskList.appendChild(listItem);
            });
        }

        function drawAxes() {
            ctx.clearRect(0, 0, axisCanvas.width, axisCanvas.height);

            // === 軸線描画 ===
            ctx.strokeStyle = "rgba(51, 51, 51, 0.7)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            // 横軸（重要度）
            ctx.moveTo(0, MATRIX_SIZE / 2);
            ctx.lineTo(MATRIX_SIZE, MATRIX_SIZE / 2);
            // 縦軸（緊急度）
            ctx.moveTo(MATRIX_SIZE / 2, 0);
            ctx.lineTo(MATRIX_SIZE / 2, MATRIX_SIZE);
            ctx.stroke();

            // === メインラベル（重要度・緊急度） ===
            ctx.font = "bold 18px sans-serif";
            ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";

            // 上部中央「緊急度」
            ctx.fillText("緊急度", MATRIX_SIZE / 2 + 45, 20);

            // 右側中央「重要度」
            ctx.fillText("重要度", MATRIX_SIZE - 60, MATRIX_SIZE / 2 - 35);

            // === 補助ラベル（高／低） ===
            ctx.font = "bold 15px sans-serif";
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // 緊急度 高（y軸左側上方）
            ctx.fillText("高", MATRIX_SIZE / 2 - 25, 25);

            // 緊急度 低（y軸左側下方）
            ctx.fillText("低", MATRIX_SIZE / 2 - 25, MATRIX_SIZE - 25);

            // 重要度 低（x軸下方左）
            ctx.fillText("低", 25, MATRIX_SIZE / 2 + 25);

            // 重要度 高（x軸下方右）
            ctx.fillText("高", MATRIX_SIZE - 25, MATRIX_SIZE / 2 + 25);
        }

        // --- ドラッグで移動（キャンバス上） ---
        function makeDraggable(task) {
            let offsetX, offsetY;
            function onPointerDown(e) {
                if (e.button !== 0) return;
                e.preventDefault();
                const rect = task.getBoundingClientRect();
                offsetX = e.clientX - (rect.left + rect.width / 2);
                offsetY = e.clientY - (rect.top + rect.height / 2);
                document.addEventListener('pointermove', onPointerMove);
                document.addEventListener('pointerup', onPointerUp);
                task.style.cursor = 'grabbing';
            }
            function onPointerMove(e) {
                const matrixRect = matrix.getBoundingClientRect();
                let x = e.clientX - matrixRect.left - offsetX;
                let y = e.clientY - matrixRect.top - offsetY;
                const halfW = task.offsetWidth / 2;
                const halfH = task.offsetHeight / 2;
                let coord = pxToCoord(x, y);
                coord.x = Math.round(coord.x / 5) * 5;
                coord.y = Math.round(coord.y / 5) * 5;
                const pos = coordToPx(coord.x, coord.y);
                task.style.left = `${pos.left - halfW}px`;
                task.style.top = `${pos.top - halfH}px`;
                updateTaskCoord(task);
                saveTasksToLocalStorage();
            }
            function onPointerUp() {
                document.removeEventListener('pointermove', onPointerMove);
                document.removeEventListener('pointerup', onPointerUp);
                task.style.cursor = 'grab';
            }
            task.addEventListener('pointerdown', onPointerDown);
        }

        // --- タスク作成 ---
        function createTask(name, time, color, deadline, x = 50, y = 50, id = null) {
            const task = document.createElement('div');
            task.className = 'task';
            task.dataset.id = id || generateId();
            task.dataset.name = name;
            task.dataset.time = time;
            task.dataset.deadline = deadline || '';
            task.style.backgroundColor = color;

            task.addEventListener('click', e => { e.stopPropagation(); selectTask(task); });
            makeDraggable(task);
            matrix.appendChild(task);
            const px = coordToPx(x, y);
            task.style.left = `${px.left - 65}px`;
            task.style.top = `${px.top - 20}px`;
            updateTaskCoord(task);
            updateTaskListOrder(getOrderFromLocalStorage());
            updateTotalTime();
            saveTasksToLocalStorage();
        }

        // --- モーダル操作 ---
        addTaskBtn.addEventListener('click', () => {
            editTarget = null;
            modalTitle.textContent = 'タスク追加';
            modalAddBtn.textContent = '追加';
            modal.style.display = 'flex';
            modalTaskName.value = '';
            modalTaskHours.value = 0;
		modalTaskMinutes.value = 1;
            modalTaskDeadline.value = '';
            modalTaskColor.value = '#4a90e2';
        });

        editTaskBtn.addEventListener('click', () => {
            if (selectedTasks.size !== 1) return;
            editTarget = [...selectedTasks][0];
            modalTitle.textContent = 'タスク編集';
            modalAddBtn.textContent = '更新';
            modalTaskName.value = editTarget.dataset.name;
		const total = parseInt(editTarget.dataset.time, 10) || 0;
    		modalTaskHours.value = Math.floor(total / 60);
    		modalTaskMinutes.value = total % 60;
            modalTaskDeadline.value = editTarget.dataset.deadline;
            modalTaskColor.value = rgbToHex(editTarget.style.backgroundColor) || '#4a90e2';
            modal.style.display = 'flex';
        });

        modalAddBtn.addEventListener('click', () => {
    		const name = modalTaskName.value.trim();
    		const hours = parseInt(modalTaskHours.value, 10) || 0;
    		const minutes = parseInt(modalTaskMinutes.value, 10) || 0;
    		const time = hours * 60 + minutes; // 合計分

    		const deadline = modalTaskDeadline.value;
    		const color = modalTaskColor.value;

    		// バリデーション（以前と同様に0分以下は受け付けない）
    		if (!name || isNaN(time) || time <= 0) return;

    		if (editTarget) {
        		editTarget.dataset.name = name;
        		editTarget.dataset.time = String(time); // dataset は文字列として扱われるので念のため String()
        		editTarget.dataset.deadline = deadline || '';
        		editTarget.style.backgroundColor = color;
        		editTarget.textContent = labelText(editTarget);
        		updateTaskListOrder(getOrderFromLocalStorage());
        		updateTotalTime();
        		saveTasksToLocalStorage();
   		} else {
        		createTask(name, time, color, deadline);
    		}
    		modal.style.display = 'none';
	});

        modalCancelBtn.addEventListener('click', () => { modal.style.display = 'none'; });

        // --- 削除/選択解除 ---
        deleteTaskBtn.addEventListener('click', () => {
            const idsToRemove = [];
            selectedTasks.forEach(task => {
                idsToRemove.push(task.dataset.id);
                matrix.removeChild(task);
            });
            clearSelection();
            updateTaskListOrder(getOrderFromLocalStorage()?.filter(id => !idsToRemove.includes(id)) || null);
            updateTotalTime();
            const order = getOrderFromLocalStorage();
            if (order) saveOrderToLocalStorage(order.filter(id => !idsToRemove.includes(id)));
            saveTasksToLocalStorage();
        });

        deselectTaskBtn.addEventListener('click', clearSelection);
        matrix.addEventListener('click', clearSelection);

        // --- おすすめ優先順位 ---
        recommendBtn.addEventListener('click', () => {
            localStorage.removeItem(ORDER_KEY);
            updateTaskListOrder();
        });

        // --- LocalStorage ---
        function saveTasksToLocalStorage() {
            const allTasks = Array.from(document.querySelectorAll('.task')).map(task => ({
                id: task.dataset.id,
                name: task.dataset.name,
                time: parseInt(task.dataset.time),
                color: task.style.backgroundColor,
                x: parseInt(task.dataset.x),
                y: parseInt(task.dataset.y),
                deadline: task.dataset.deadline || ''
            }));
            localStorage.setItem(STORAGE_KEY, JSON.stringify(allTasks));
        }

        function getOrderFromLocalStorage() {
            const raw = localStorage.getItem(ORDER_KEY);
            if (!raw) return null;
            try { return JSON.parse(raw); } catch { return null; }
        }

        function saveOrderToLocalStorage(orderIds) {
            localStorage.setItem(ORDER_KEY, JSON.stringify(orderIds));
        }

        function loadTasksFromLocalStorage() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;
            try {
                const arr = JSON.parse(saved);
                if (!Array.isArray(arr)) return;
                arr.forEach(t => {
                    const id = t.id || generateId();
                    createTask(t.name, parseInt(t.time), t.color, t.deadline, parseInt(t.x), parseInt(t.y), id);
                });
                const order = getOrderFromLocalStorage();
                if (order) updateTaskListOrder(order);
                updateTotalTime();
            } catch (e) {
                console.error('データの読み込みに失敗しました', e);
            }
        }

        // --- 日付変化で y を +2 シフト ---
        function applyDailyShiftIfNeeded() {
            const today = todayStr();
            const last = localStorage.getItem(SHIFT_KEY);
            if (!last) {
                localStorage.setItem(SHIFT_KEY, today);
                return;
            }
            const diff = daysBetween(last, today);
            if (diff <= 0) return;
            const inc = 2 * diff;
            document.querySelectorAll('.task').forEach(task => {
                const x = parseInt(task.dataset.x);
                let y = parseInt(task.dataset.y);
                y = Math.min(COORD_MAX, y + inc);
                task.dataset.y = y;
                const px = coordToPx(x, y);
                const rect = task.getBoundingClientRect();
                const halfW = rect.width / 2;
                const halfH = rect.height / 2;
                task.style.left = `${px.left - halfW}px`;
                task.style.top = `${px.top - halfH}px`;
                task.textContent = labelText(task);
            });
            updateTaskListOrder(getOrderFromLocalStorage());
            saveTasksToLocalStorage();
            localStorage.setItem(SHIFT_KEY, today);
        }

        let currentDateString = todayStr();
        setInterval(() => {
            const nowStr = todayStr();
            if (nowStr !== currentDateString) {
                currentDateString = nowStr;
                applyDailyShiftIfNeeded();
            }
        }, 60 * 1000);

        // --- rgb -> hex 変換（正規表現なし） ---
        function rgbToHex(rgb) {
            if (!rgb) return null;
            if (rgb[0] === '#') return rgb;
            const nums = [];
            let buf = '';
            for (let i = 0; i < rgb.length; i++) {
                const c = rgb[i];
                if (c >= '0' && c <= '9') buf += c;
                else {
                    if (buf.length) { nums.push(parseInt(buf, 10)); buf = ''; }
                }
            }
            if (buf.length) { nums.push(parseInt(buf, 10)); }
            if (nums.length < 3) return null;
            const [r, g, b] = nums;
            const toHex = n => n.toString(16).padStart(2, '0');
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }


        /* --- 最後に初期化 --- */
        document.addEventListener('DOMContentLoaded', () => {
            drawAxes();
            modal.style.display = 'none';
            loadTasksFromLocalStorage();
            applyDailyShiftIfNeeded();
            renderCompletedTasks(); // ←追加
        });
    </script>
</body>
</html>
